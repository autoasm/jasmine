// Class automatically generated by Dev-C++ New Class wizard

#include "classloader.h" // class's header file
#include "toolkit.h"
#include "constant.h"
#include "constantfloat.h"
#include "constint.h"
#include "constantlong.h"
#include "constantnameandtype.h"
#include "constantref.h"
#include "constantstring.h"
#include "constantunicode.h"
#include "constantutf8.h"
#include "constclass.h"
#include "genericattribute.h"
#include "methodinfo.h"
#include "constmethodref.h"
#include "constfieldref.h"
#include "constintfmethodref.h"
#include <stdio.h>
#include <assert.h>
#include <iostream>


// class constructor
ClassLoader::ClassLoader()
{
	// insert your code here
	classFileExt = CLASS_EXT;
	classBuf = NULL;
}

// class destructor
ClassLoader::~ClassLoader()
{
    if(classBuf != NULL) {
        delete[] classBuf;
    }
	// insert your code here
}

//-------------------------------------------------------------

BOOL ClassLoader::loadClassIntoBuf(string classFile){
    BOOL ret = false;
    FILE*fp = fopen(classFile.c_str(), "rb");
    if(fp){
        //Get size of class file
        fseek(fp,0,SEEK_END);
        classBufSize = ftell(fp);
        fseek(fp,0,0);
        
        //Alloc Buffer
        classBuf = new BYTE[classBufSize];
        memset(classBuf,0,sizeof(BYTE)*classBufSize);
        
        // read class file data into buffer
        fread(classBuf,sizeof(BYTE),classBufSize,fp);
        
        fclose(fp);
        
        ret = true;
    }
    return ret;
}

//---------------------------------------------------------------

JClass* ClassLoader::loadClass(string className)
{
    JClass*ret = NULL;
    string ext(classFileExt);
    string classFileName = className + ext;

    if(loadClassIntoBuf(classFileName))
    {
        UINT tmp = 0;
        UINT&index = tmp;
        
        u4 magic  = 0;
        u2 minorV = 0;
        u2 majorV = 0;
        u2 constPoolCount = 0;
        u2 accessFlag = 0;
        u2 thisClass = 0;
        u2 superClass = 0;
        u2 intfCount  = 0;
        u2 fieldsCount = 0;
        u2 methodsCount = 0;
        u2 attributesCount = 0;
        
        ret = new JClass();
        
        // Magic Number
        magic = ToolKit::memGetU4(classBuf, index);
        ret->setMagic(magic);
        // Minor Version 
        minorV = ToolKit::memGetU2(classBuf, index);
        ret->setMinorVersion(minorV);
        // Major Version
        majorV = ToolKit::memGetU2(classBuf, index);
        ret->setMajorVersion(majorV);
        // Constant Pool Count
        constPoolCount = ToolKit::memGetU2(classBuf, index);
        ret->setConstPoolCount(constPoolCount);
        // Constant Pool
        ret->initConstantPool(constPoolCount);
        handleConstantPool(ret,constPoolCount,index);
        
        // Asscess Flags
        accessFlag = ToolKit::memGetU2(classBuf, index);
        ret->setAccessFlag(accessFlag);
        // This Class
        thisClass  = ToolKit::memGetU2(classBuf, index);
		ret->setThisClass(thisClass);
        // Super Class
        superClass = ToolKit::memGetU2(classBuf, index);
		ret->setSuperClass(superClass);
        // Interfaces Count
        intfCount  = ToolKit::memGetU2(classBuf, index);
        ret->setInterfaceCount(intfCount);
        if(intfCount > 0) {
            ret->initInterfaces(intfCount);
            handleInterfaces(ret,intfCount,index);
        }
        // Fields Count
        fieldsCount = ToolKit::memGetU2(classBuf, index);
        ret->setFieldsCount(fieldsCount);
        if(fieldsCount > 0) {
            //Fields
            ret->initFields(fieldsCount);
            handleFields(ret,fieldsCount,index);
        }
        // Methods Count
        methodsCount = ToolKit::memGetU2(classBuf, index);
        ret->setMethodsCount(methodsCount);
        if(methodsCount > 0) {
            //Methods
            ret->initMethods(methodsCount);
            handleMethods(ret,methodsCount,index);
        }
        
        attributesCount = ToolKit::memGetU2(classBuf, index);
        ret->setAttributesCount(attributesCount);
        if(attributesCount > 0) {
            // Attributes
            ret->initAttributes(attributesCount);
            handleAttribute(ret, attributesCount, index);
        }
    }
    return ret;
}

//-----------------------------------------------------------

UINT ClassLoader::onConstantUtf8(JClass*javaClass, UINT&index)
{
#ifdef JASM_DEBUG
    cout << "Constant UTF " << endl;
#endif
    UINT ret = J_OK;
    u2 utfLen = ToolKit::memGetU2(classBuf,index);
    //ToolKit::memGetUtfString(classBuf, index, NULL,utfLen);
    ConstantUtf8 * utf = new ConstantUtf8(utfLen);
    ToolKit::memGetUtfString(classBuf, index, utf->getBytes(),utfLen);
    javaClass->addConstant(utf);
    return ret;
}

UINT ClassLoader::onConstantUnicode(JClass*javaClass,UINT&index)
{
#ifdef JASM_DEBUG
    cout << "Constant Unicode" << endl;
#endif
    UINT ret = J_OK;
    
    u2 unicodeLen = ToolKit::memGetU2(classBuf,index);
    ConstantUnicode* unicode = new ConstantUnicode(unicodeLen);
    ToolKit::memGetUnicodeString(classBuf, index, unicode->getBytes(),unicodeLen);
    javaClass->addConstant(unicode);    
    return ret;
}

UINT ClassLoader::onConstantString(JClass*javaClass, UINT&index)
{
#ifdef JASM_DEBUG
    cout << "Constant String " << endl;
#endif
    UINT ret = J_OK;
    ConstantString*consString = new ConstantString();
    u2 stringIndex = ToolKit::memGetU2(classBuf,index);
    consString->setStringIndex(stringIndex);
    javaClass->addConstant(consString); 
    return ret;
}

UINT ClassLoader::onConstantInteger(JClass*javaClass, UINT&index)
{
#ifdef JASM_DEBUG
    cout << "Constant Integer" << endl;
#endif
    UINT ret = J_OK;
    ConstantInt * constInt = new ConstantInt();
    u4 bytes = ToolKit::memGetU4(classBuf,index);
    constInt->setValue(bytes);
    javaClass->addConstant(constInt);
    return ret;
}

UINT ClassLoader::onConstantLong(JClass*javaClass,UINT&index)
{
#ifdef JASM_DEBUG
    cout << "Constant Long" << endl;
#endif
    UINT ret = J_OK;
    ConstantLong* constLong = new ConstantLong();
    u4 highByte =   ToolKit::memGetU4(classBuf,index);
    constLong->setHighByte(highByte);
    u4 lowByte =    ToolKit::memGetU4(classBuf,index);
    constLong->setLowByte(lowByte);
    javaClass->addConstant(constLong);
    return ret;
}

UINT ClassLoader::onConstantFloat(JClass*javaClass,UINT&index)
{
#ifdef JASM_DEBUG
    cout << "Constant Float" << endl;
#endif
    UINT ret = J_OK;
    ConstantFloat*constFloat = new ConstantFloat();
    u4 floatByte = ToolKit::memGetU4(classBuf,index);
    constFloat->setValue((float)floatByte);
    javaClass->addConstant(constFloat);
    return ret;
}

UINT ClassLoader::onConstantDouble(JClass*javaClass,UINT&index)
{
#ifdef JASM_DEBUG
    cout << "Constant Double" << endl;
#endif
    UINT ret = J_OK;
    Constant* constant = new Constant();
    u4 highByte =   ToolKit::memGetU4(classBuf,index);
    u4 lowByte =    ToolKit::memGetU4(classBuf,index);  
    javaClass->addConstant(constant);  
    return ret;
}

UINT ClassLoader::onConstantReference(JClass*javaClass, UINT&index, u1 constantTag)
{
#ifdef JASM_DEBUG
    cout << "Constant Reference " << endl;
#endif
    UINT ret = J_OK;
    ConstantRef* constRef = (ConstantRef*)0;
	if(constantTag == Constant::FIELD_REF) {
		constRef = new ConstFieldRef();
	}
	else if(constantTag == Constant::METHOD_REF) {
		constRef = new ConstMethodRef();
	}
	else {
		constRef = new ConstIntfMethodRef();
	}

    u2 classindex = ToolKit::memGetU2(classBuf,index);
    constRef->setClassIndex(classindex);
    u2 nameAndType = ToolKit::memGetU2(classBuf,index);
    constRef->setNameAndTypeIndex(nameAndType);
    javaClass->addConstant(constRef);
    return J_OK;
}

UINT ClassLoader::onConstantClass(JClass*javaClass,UINT&index)
{
#ifdef JASM_DEBUG
    cout << "Constant Class " << endl;
#endif
    UINT ret = J_OK;
    ConstantClass* constClass = new ConstantClass();
    u2 className = ToolKit::memGetU2(classBuf,index);
    constClass->setNameIndex(className);
    javaClass->addConstant(constClass);
    return ret;
}

UINT ClassLoader::onConstantNameAndType(JClass*javaClass,UINT&index)
{
#ifdef JASM_DEBUG
    cout << "Constant Name and Type " << endl;
#endif
    UINT ret = J_OK;
    ConstantNameAndType* nameAndType = new ConstantNameAndType();
    u2 typeName = ToolKit::memGetU2(classBuf,index);
    nameAndType->setNameIndex(typeName);
    u2 signature = ToolKit::memGetU2(classBuf,index); 
    nameAndType->setSignatureIndex(signature);
    javaClass->addConstant(nameAndType);
    return ret;
}

//----------------------------------------------------------------------

UINT ClassLoader::handleConstantPool(JClass*javaClass,UINT constantCount,UINT&index)
{
    assert(javaClass != NULL);
    assert(classBuf != NULL);
    u1 tag = 0;
    for(UINT i = 1; i< constantCount; i++) {
        tag = ToolKit::memGetU1(classBuf, index);
        if(tag == Constant::UTF8) {             // Constant UTF8
            onConstantUtf8(javaClass,index);
        }
        else if(tag == Constant::STRING) {      // Constant String
            onConstantString(javaClass,index);
        }
        else if(tag == Constant::INTEGER) {     // Constant Integer
            onConstantInteger(javaClass,index);      
        }
        else if(tag == Constant::LONG) {        // Constant Long
            onConstantLong(javaClass,index);
        }
        else if(tag == Constant::FLOAT) {       // Constant Float
            onConstantFloat(javaClass,index);
        }
        else if(tag == Constant::DOUBLE) {      // Constant Double
            onConstantDouble(javaClass,index);
        }
        else if(tag == Constant::CLASS) {       // Constant Class
            onConstantClass(javaClass,index);
        }   
        else if((tag >= Constant::FIELD_REF) && (tag <= Constant::INTF_METHOD_REF )) {
            onConstantReference(javaClass, index, tag);// Constant Reference
        }
        else if(tag == Constant::NAME_AND_TYPE) {// Constant Name And Type
            onConstantNameAndType(javaClass,index);
        }      
        else if(tag == Constant::UNICODE) {     // Constant Unicode
            onConstantUnicode(javaClass,index);
        }
        else {
            cout << "Parse Constant Pool Error!" << endl;
        }
    }
	return 0;
}

//------------------------------------------------------------------------

UINT ClassLoader::handleInterfaces(JClass*javaClass,u2 intfCount,UINT&index) {
    UINT ret = J_ERROR;
    assert(javaClass != NULL);
    u2*intfs = javaClass->getInterfaces();
    if(intfs) {
        for(int i = 0; i<intfCount; i++) {
            javaClass->setInterface(ToolKit::memGetU2(classBuf,index),i);
        }
        ret = J_OK;
    }    
    return ret;
}

//------------------------------------------------------------------------

UINT ClassLoader::handleFields(JClass*javaClass,u2 fieldsCount, UINT&index) {
    UINT ret = J_ERROR;
    assert(javaClass != NULL);
    for( int i = 0; i<fieldsCount; i++) {
        // Get Access Flags
        u2 accessFlags = ToolKit::memGetU2(classBuf,index);
        // Get Name Index
        u2 nameIndex   = ToolKit::memGetU2(classBuf,index);
        // Get Signature
        u2 signatureIndex  = ToolKit::memGetU2(classBuf,index);
        // Get Attribute Count
        u2 attributesCount = ToolKit::memGetU2(classBuf,index);
        
        //TODO: Constructor field object and add it to java class.
        FieldInfo* field = new FieldInfo();
        //TODO: Set fields of object field
        field->setAccessFlag(accessFlags);
        field->setNameIndex(nameIndex);
        field->setSignatureIndex(signatureIndex);
        field->setAttributesCount(attributesCount);
        ret = handleAttribute(field,attributesCount,index);
        //TODO: Add field into javaClass
        javaClass->setField(field,i);
        ret = J_OK;
    }
    return ret;
}

//------------------------------------------------------------------------

UINT ClassLoader::handleAttribute(AttributeContainer*owner, u2 attributesCount, UINT&index)
{
    UINT ret = J_ERROR;
    assert(owner != NULL);
    for( int i = 0; i < attributesCount; i++) {
        u2 attributeName    = ToolKit::memGetU2(classBuf,index);
        u4 attributeLength  = ToolKit::memGetU4(classBuf,index);
         
        GenericAttribute* attribute = new GenericAttribute();
        //Set Attribute Name
        attribute->setAttributeName(attributeName);
        //Set Attribute Length
        attribute->setAttributeLength(attributeLength);
        attribute->initInfo(attributeLength);
        //Get Attributes
        ToolKit::memGetU1Array(classBuf,index, attribute->getInfo(), attributeLength);

        owner->setAttribute(attribute,i);
        ret = J_OK;
    }
    return ret;
}

UINT ClassLoader::handleMethods(JClass*javaClass,u2 methodsCount, UINT&index)
{
    UINT ret = J_ERROR;
    assert(javaClass != NULL);
    for( int i = 0; i < methodsCount; i++) {
        u2 accessFlags     = ToolKit::memGetU2(classBuf,index);
        u2 nameIndex       = ToolKit::memGetU2(classBuf,index);
        u2 signatureIndex  = ToolKit::memGetU2(classBuf,index);
        u2 attributesCount = ToolKit::memGetU2(classBuf,index);
        
        MethodInfo*method = new MethodInfo();
        method->setAccessFlags(accessFlags);
        method->setNameIndex(nameIndex);
        method->setSignatureIndex(signatureIndex);
        method->setAttributesCount(attributesCount);
        ret = handleAttribute(method,attributesCount,index);
 
        javaClass->setMethod(method,i);
        ret = J_OK;
    }
    return ret;
}
