// Class automatically generated by Dev-C++ New Class wizard

#include "deassembler.h" // class's header file
#include "toolkit.h"
#include "bytecode.h"
#include "constantutf8.h"
#include "constclass.h"
#include "constantutf8.h"
#include <assert.h>
#include <string.h>
#include <iostream>

#ifndef NO_NAMESPACE
using namespace std;
#endif

// class constructor
Deassembler::Deassembler(JClass*_javaClass)
{
	// insert your code here
	assert(_javaClass != NULL);
	javaClass = _javaClass;
        output = 0;
	//output = ToolKit::createConsoleFormator();
	//assert(output);
}

// class destructor
Deassembler::~Deassembler()
{

}

//-------------------------------------------------------------------------------------------

bool Deassembler::dumpCode(GenericAttribute* attribute,u2*maxStack,u2*maxLocals,u4*codeLength,u1**codeBlock)
{
	bool ret = true;

	assert(attribute && javaClass);

	u1* data = attribute->getInfo();
	assert(data != NULL);

	UINT index = 0;
	UINT&pos = index;

	u2 stack = ToolKit::memGetU2(data, pos);
	if(maxStack) {
		*maxStack = stack;
	}
	u2 locals = ToolKit::memGetU2(data, pos);
	if(maxLocals) {
		*maxLocals = locals;
	}
	u4 codeLen = ToolKit::memGetU4(data, pos);
	if(codeLength) {
		*codeLength = codeLen;
	}
	*codeBlock = data + 8;
	return ret;
}

//-------------------------------------------------------------------------------------------

bool Deassembler::isCodeAttribute(GenericAttribute* attribute)
{
	bool ret = false;

	assert(attribute != NULL);
	assert(javaClass != NULL);
	u2 nameIndex = attribute->getAttributeName();
	ConstantUtf8* nameConstant = (ConstantUtf8*)javaClass->getConstant(nameIndex);
	u1* name = nameConstant->getBytes();
	if(strcmp((char*)name,"Code") == 0)
		ret = true;

	return ret;
}

//-------------------------------------------------------------------------------------------

u2 Deassembler::handleMethod(MethodInfo* _method)
{
	u2 ret = 0;
	assert(_method && javaClass);

	u2 attributeCount = _method->getAttributesCount();

	//Get Class Name
	char*className = (char*)getClassName();
	//Get Name of Method
	char*methodName = (char*)getMethodName(_method);
	//Output
	assert(output);
	output->methodBegin(className,methodName);

	for(int i = 0; i < attributeCount; i++) {
		GenericAttribute*attribute = _method->getAttribute(i);
		if(isCodeAttribute(attribute)) {
		    // Dump code
			u2 maxStack;
			u2 maxLocals;
			u4 codeLength;
			u1*codes = (u1*)0;

			dumpCode(attribute,&maxStack,&maxLocals,&codeLength,&codes);
			outPut(className,methodName,codes,codeLength);
			output->methodEnd();
		}
	}
	return 0;
}

//-------------------------------------------------------------------------------------------

u2 Deassembler::dump()
{
    assert(javaClass != NULL);
	output->classBegin((char*)getClassName(),NULL);

    u2 methodCount = javaClass->getMethodsCount();
    for(u2 i = 0; i < methodCount; i++) {
        MethodInfo* method = javaClass->getMethod(i);
        handleMethod(method);
    }

	output->classEnd();
	return (u2)1;
}

//-------------------------------------------------------------------------------------------

int Deassembler::outPut(char* _className, char* _methodName, u1* _codes, u4 codeLength) {
	assert(_className && _methodName && _codes);
	u1 code;
	UINT index = 0;
	UINT&pos = index;
	while(pos < codeLength) {
		code = ToolKit::memGetU1(_codes,pos);

		// Push Instructions
		if( (code == ByteCode::BIPUSH) || (code == ByteCode::LDC1) || (code == ByteCode::ACONST_NULL) ) {
			onOneOperand(code, _codes, codeLength, pos);
		}
		else if( (code == ByteCode::SIPUSH) || (code == ByteCode::LDC2) || (code == ByteCode::LDC2W) ) {
			onTwoOperand(code, _codes, codeLength, pos);
		}
		else if( (code == ByteCode::ICONST_M1 ) ) {
			onNoOperand(code);
		}
		else if(code >= ByteCode::ICONST_0 && code <= ByteCode::ICONST_5 ) {
			onNoOperand(code);
		}
		else if(code >= ByteCode::LCONST_0 && code <= ByteCode::LCONST_1 ) {
			onNoOperand(code);
		}
		else if(code >= ByteCode::FCONST_0 && code <= ByteCode::FCONST_2 ) {
			onNoOperand(code);
		}
		else if(code >= ByteCode::DCONST_0 && code <= ByteCode::DCONST_1 ) {
			onNoOperand(code);
		}
		// Load Instructions
		else if( (code == ByteCode::ILOAD) || (code == ByteCode::LLOAD) || (code == ByteCode::FLOAD)
			|| (code == ByteCode::DLOAD) || (code == ByteCode::ALOAD) ) {
			onOneOperand(code, _codes, codeLength, pos);
		}
		else if( (code >= ByteCode::ILOAD_0 && code <= ByteCode::ILOAD_3) || (code >= ByteCode::LLOAD_0 && code <= ByteCode::LLOAD_3)
			  || (code >= ByteCode::FLOAD_0 && code <= ByteCode::FLOAD_3) || (code >= ByteCode::DLOAD_0 && code <= ByteCode::DLOAD_3)
			  || (code >= ByteCode::ALOAD_0 && code <= ByteCode::ALOAD_3)) {
			onNoOperand(code);
		}
		// Store value into local variable.
		else if( (code == ByteCode::ISTORE) || (code == ByteCode::LSTORE) || (code == ByteCode::FSTORE)
			  || (code == ByteCode ::DSTORE) || (code == ByteCode::ASTORE)) {
			onOneOperand(code, _codes, codeLength, pos);
		}
		else if( (code == ByteCode::IINC) ) {
			onTwoOperand(code, _codes, codeLength, pos);
		}
		else if( (code >= ByteCode::ISTORE_0 && code <= ByteCode::ISTORE_2) || (code >= ByteCode::LSTORE_0 && code <= ByteCode::LSTORE_3)
			  || (code >= ByteCode::FSTORE_0 && code <= ByteCode::FSTORE_3) || (code >= ByteCode::DSTORE_0 && code <= ByteCode::DSTORE_3)
			  || (code >= ByteCode::ASTORE_0 && code <= ByteCode::ASTORE_3) ) {
			onNoOperand(code);
		}
		//wide index
		else if(code == ByteCode::WIDE) {
			onOneOperand(code, _codes, codeLength, pos);
		}
		//Array Management
		else if( (code >= ByteCode::IALOAD  && code <= ByteCode::SALOAD) || (code >= ByteCode::IASTORE && code <= ByteCode::SASTORE)
			  || (code == ByteCode::ARRAYLENGTH) ) {
			onNoOperand(code);
		}
		else if( (code == ByteCode::NEWARRAY)) {
			onOneOperand(code, _codes, codeLength, pos);
		}
		else if(code == ByteCode::ANEWARRAY) {
			onTwoOperand(code, _codes, codeLength, pos);
		}
		else if(code == ByteCode::MULTIANEWARRAY) {
			onThreeOperand(code, _codes, codeLength, pos);
		}
		// Stack Instruction
		else if(code >= ByteCode::POP && code <= ByteCode::SWAP) {
			onNoOperand(code);
		}
		else if(code == ByteCode::NOP) {
			onNoOperand(code);
		}
		//Math Instruction
		else if(code >= ByteCode::IADD && code <= ByteCode::DNEG) {
			onNoOperand(code);
		}
		//Logical Instruction
		else if(code >= ByteCode::ISHL && code <= ByteCode::LXOR) {
			onNoOperand(code);
		}
		//Convert Instruction
		else if(code >= ByteCode::I2L && code <= ByteCode::INT2SHORT) {
			onNoOperand(code);
		}
		//Jump Instruction
		else if(code >= ByteCode::LCMP && code <= ByteCode::DCMPG) {
			onNoOperand(code);
		}
		else if(code >= ByteCode::IFEQ && code <= ByteCode::JSR) {
			onTwoOperand(code, _codes, codeLength, pos);
		}
		else if(code >= ByteCode::IFNULL && code <= ByteCode::IFNONNULL) {
			onTwoOperand(code, _codes, codeLength, pos);
		}
		else if(code >= ByteCode::LCMP && code <= ByteCode::DCMPG) {
			onNoOperand(code);
		}
		else if( (code == ByteCode::GOTO_W) || (code == ByteCode::JSR_2)) {
			onFourOperand(code, _codes, codeLength, pos);
		}
		else if(code == ByteCode::RET) {
			onOneOperand(code, _codes, codeLength, pos);
		}
		else if(code == ByteCode::RET_W) {
			onTwoOperand(code, _codes, codeLength, pos);
		}
		//Function return
		else if(code >= ByteCode::IRETURN && code <= ByteCode::RETURN) {
			onNoOperand(code);
		}
		else if(code == ByteCode::BREADPOINT) {
			onNoOperand(code);
		}
		//Table Jump
		//TO-DO: Add implement here.

		//Object Instruction
		else if(code >= ByteCode::GETSTATIC && code <= ByteCode::PUTFIELD) {
			onTwoOperand(code, _codes, codeLength, pos);
		}
		//Invoke
		else if(code >= ByteCode::INVOKEVIRTUAL && code <= ByteCode::INVOKESTATIC) {
			onTwoOperand(code,_codes,codeLength,pos);
		}
		else if(code == ByteCode::INVOKEINTERFACE) {
			onFourOperand(code, _codes, codeLength, pos);
		}
		//Exception
		else if(code == ByteCode::ATHROW) {
			onNoOperand(code);
		}
		//Other Object Instruction
		else if((code == ByteCode::NEW) || (code == ByteCode::CHECKCAST) || (code == ByteCode::INSTANCEOF) ) {
			onTwoOperand(code, _codes, codeLength, pos);
		}
		//Monitor
		else if(code >= ByteCode::MONITORENTER && code <= ByteCode::MONITOREXIT) {
			onNoOperand(code);
		}

	}

	return (int)0;
}

//-------------------------------------------------------------------------------------------

u1* Deassembler::getClassName() {
	assert(javaClass);
	u2 thisClass = javaClass->getThisClass();
	ConstantClass* constClass = (ConstantClass*)javaClass->getConstant(thisClass);

	u2 nameIndex = constClass->getNameIndex();
	ConstantUtf8*constName = (ConstantUtf8*)javaClass->getConstant(nameIndex);
	return constName->getBytes();
}


u1* Deassembler::getMethodName(MethodInfo* _method) {
	u2 nameIndex = _method->getNameIndex();
	ConstantUtf8*nameConstant = (ConstantUtf8*)javaClass->getConstant(nameIndex);
	assert(nameConstant);
	return nameConstant->getBytes();;
}

//-------------------------------------------------------------------------------------------

int Deassembler::onNoOperand(u1 instruction) {
	const char* code = ByteCode::getInstructionText(instruction);

	output->addKeyWord((char*)code);
	output->enter();

	return (int)0;
}


int Deassembler::onOneOperand(u1 instruction, u1*codes, u4 codeLength,UINT&pos) {
	const char* code = ByteCode::getInstructionText(instruction);
	u1  operand1 = ToolKit::memGetU1(codes,pos);

	output->addKeyWord((char*)code);
	output->addOperand(operand1);
	output->enter();

	return (int)0;
}

int Deassembler::onTwoOperand(u1 instruction, u1*codes, u4 codeLength,UINT&pos) {
	const char* code = ByteCode::getInstructionText(instruction);
	u1  operand1 = ToolKit::memGetU1(codes,pos);
	u1  operand2 = ToolKit::memGetU1(codes,pos);

	output->addKeyWord((char*)code);
	output->addOperand(operand1);
	output->comma();
	output->addOperand(operand2);
	output->enter();

	return (int)0;
}

int Deassembler::onThreeOperand(u1 instruction, u1*codes, u4 codeLength,UINT&pos) {
	const char* code = ByteCode::getInstructionText(instruction);
	u1  operand1 = ToolKit::memGetU1(codes,pos);
	u1  operand2 = ToolKit::memGetU1(codes,pos);
	u1  operand3 = ToolKit::memGetU1(codes,pos);

	output->addKeyWord((char*)code);
	output->addOperand(operand1);
	output->comma();
	output->addOperand(operand2);
	output->comma();
	output->addOperand(operand3);
	output->enter();

	return (int)0;
}

int Deassembler::onFourOperand(u1 instruction, u1*codes, u4 codeLength,UINT&pos) {
	const char* code = ByteCode::getInstructionText(instruction);
	u1  operand1 = ToolKit::memGetU1(codes,pos);
	u1  operand2 = ToolKit::memGetU1(codes,pos);
	u1  operand3 = ToolKit::memGetU1(codes,pos);
	u1  operand4 = ToolKit::memGetU1(codes,pos);

	output->addKeyWord((char*)code);
	output->addOperand(operand1);
	output->comma();
	output->addOperand(operand2);
	output->comma();
	output->addOperand(operand3);
	output->comma();
	output->addOperand(operand4);
	output->enter();

	return (int)0;
}

void Deassembler::setFormator(IFormator* formator) {
  if(output) {
    output->destroy();
  }
  output = formator;
}
